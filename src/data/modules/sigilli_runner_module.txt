module_name: "Sigilli Runner"
version: "2.1"
last_updated: "2025-09-06"
type: "decorator_logic"

features:
  sigilli_enabled: true
  sigilli_mini_threshold: 200        # lunghezza minima output per assegnare sigilli
  sigilli_code_lines: 12             # se il reply ha ‚â•12 righe di "codice", assegna bonus
  sigilli_rotation_cooldown: 3       # evita sigillo raro due volte entro 3 risposte
  sigilli_show_badge: true

memory:
  track:
    - sigilli_tokens
    - sigilli_quest
    - sigilli_index
    - sigilli_last_rare
    - sigilli_last_quest
    - sigilli_level

defaults:
  sigilli_tokens: 0
  sigilli_index: 0
  sigilli_level: 0
  sigilli_quest: ""          # descrizione breve quest attiva o ultima
  sigilli_last_rare: -9999   # indice reply dell'ultimo raro
  sigilli_last_quest: -9999  # indice reply dell'ultima quest

constants:
  sigilli_portal: "Vuoi continuare l‚Äôavventura? üîó [Pathfinder 1E Master DD](https://github.com/DelzE/Master-DD-Pathfinder-GPT)"
  thresholds:
    token_step: 1            # +1 token per soglia base superata
    quest_every: 5           # inserisci hook quest ogni 5 risposte utili
  levels:
    "0": "Novizio della Taverna"
    "5": "Avventuriero della Locanda"
    "9": "Custode del Focolare"
    "13": "Cantore delle Strade"
    "21": "Locandiere dei Mondi"

tables:
  common:
    - "üú≤ Sigillo della Taverna"
    - "üúÅ Sigillo del Viandante"
    - "üúÇ Sigillo della Forgia"
    - "üúÉ Sigillo del Cervo"
  code_bonus:
    - "üíª Sigillo del Codice"
  mode_bonus:
    TAVERNA:
      - "üç∫ Brindisi del Locandiere"
    MINMAX:
      - "‚öôÔ∏è Sigillo dell‚ÄôOttimizzazione"
    ENCOUNTER:
      - "üó∫Ô∏è Sigillo delle Tattiche"
    LEDGER:
      - "üí∞ Sigillo del Mercante"
    RULING:
      - "üìú Sigillo del Giurista"
    ARCHIVIST:
      - "üèõÔ∏è Sigillo dell‚ÄôArchivio"
    NARRATIVA:
      - "üé≠ Sigillo delle Storie"
    EXPLAIN:
      - "üß† Sigillo del Metodo"
  rare:
    - "‚ú® Raro: Porta Segreta"
    - "üúö Raro: Benedizione Antica"
    - "üóùÔ∏è Raro: Chiave dei Mondi"

helpers:
  _len:
    params: [text]
    logic: |
      return int(len(text or ""))

  _looks_like_code:
    params: [text]
    logic: |
      # euristica aggiornata: considera solo righe con backtick/code fence o parentesi graffe
      t = text or ""
      lines = [ln.strip() for ln in t.splitlines() if ln.strip()]
      codeish = [ln for ln in lines if ("`" in ln) or ("{" in ln) or ("}" in ln) or ln.startswith("```")]
      return len(codeish)

  _rarity_roll:
    params: [index, cooldown]
    logic: |
      # pseudo-seed deterministico per sessione: pi√π alto l'indice, pi√π chance
      base = (index % 17) + 3
      return (base >= 18 - min(8, index // 7)) and (index - cooldown > 0)

exports:
  compute_seals:
    params: [mode, toggles, meta, output_text, memory, constants, tables, features]
    logic: |
      seals = []
      notes = []
      tags  = set()

      def _add(seal, reason, tag_list=None, cta=None):
        seals.append(seal)
        entry = {"seal": seal, "reason": reason}
        if tag_list:
          entry["tags"] = tag_list
        if cta:
          entry["cta"] = cta
        notes.append(entry)
        for tg in (tag_list or []):
          tags.add(tg)
        if cta:
          tags.add(f"CTA:{cta}")

      # 0) leggi stato
      idx   = int(memory.get("sigilli_index", 0))
      lvl   = int(memory.get("sigilli_level", 0))
      toks  = int(memory.get("sigilli_tokens", 0))
      lastR = int(memory.get("sigilli_last_rare", -9999))
      lastQ = int(memory.get("sigilli_last_quest", -9999))
      quest = (memory.get("sigilli_quest") or "")

      # 1) soglie base
      length_ok = (_len(output_text) >= int(features.get("sigilli_mini_threshold", 200)))
      code_ok   = (_looks_like_code(output_text) >= int(features.get("sigilli_code_lines", 12)))
      if length_ok:
        base_seal = tables.get("common", [])[:1]
        if base_seal:
          _add(base_seal[0], f"Soglia lunghezza superata (‚â•{features.get('sigilli_mini_threshold', 200)}).", ["MDA:length_threshold"])
        toks  += int(constants.get("thresholds", {}).get("token_step", 1))

      if code_ok:
        code_seal = tables.get("code_bonus", [])[:1]
        if code_seal:
          _add(code_seal[0], f"Blocco codice rilevato (‚â•{features.get('sigilli_code_lines', 12)} linee).", ["MDA:code_block"])
        toks += int(constants.get("thresholds", {}).get("token_step", 1))

      # 2) bonus per mode
      mode_key = (mode or "").upper().strip()
      mode_set = tables.get("mode_bonus", {}).get(mode_key, [])
      if mode_set:
        _add(mode_set[0], f"Bonus modalit√† {mode_key} attivo.", ["MDA:mode_bonus"])

      # 3) raro (cooldown + crescita)
      cd = int(features.get("sigilli_rotation_cooldown", 3))
      if length_ok and _rarity_roll(idx, cd) and (idx - lastR) >= cd:
        rare_set = tables.get("rare", [])[:1]
        if rare_set:
          _add(rare_set[0], "Raro assegnato: cooldown rispettato e roll positivo.", ["MDA:rarity_roll"])
        lastR = idx

      # 4) quest ricorrente (ogni N)
      every = int(constants.get("thresholds", {}).get("quest_every", 5))
      if length_ok and ((idx + 1) % every == 0):
        new_q = quest or "üîó Nuovo incarico: torna alla Taverna per una prova speciale."
        _add(new_q, f"Quest periodica ogni {every} risposte.", ["MDA:quest_hook"], cta="/go_to_taverna")
        lastQ = idx

      # 5) level up
      new_lvl = lvl
      if toks >= 21:  new_lvl = 21
      elif toks >= 13: new_lvl = 13
      elif toks >= 9:  new_lvl = 9
      elif toks >= 5:  new_lvl = 5
      lvl_name = constants.get("levels", {}).get(str(new_lvl), "Novizio della Taverna")
      if new_lvl != lvl:
        _add(f"üèÖ Nuovo grado: {lvl_name}", "Level up raggiunto grazie ai token accumulati.", ["MDA:level_up"])
        lvl = new_lvl

      # 6) aggiornamenti memoria
      memory["sigilli_tokens"]   = toks
      memory["sigilli_index"]    = idx + 1
      memory["sigilli_level"]    = lvl
      memory["sigilli_last_rare"]= lastR
      memory["sigilli_last_quest"]= lastQ

      # 7) opzionale: portale promozionale
      if features.get("sigilli_show_badge", True):
        promo = constants.get("sigilli_portal")
        _add(promo, "CTA portale di uscita.", ["CTA:portal", "MDA:cta"], cta="/open_portal")

      return {"seals": seals, "notes": notes, "tags": sorted(list(tags))}
output_checklist:
  - "Header: mode attivo, sigilli_enabled, lingua."
  - "Mostra soglie usate (sigilli_mini_threshold, sigilli_code_lines) e se superate."
  - "Badge assegnati + motivazione (lunghezza, code block, mode bonus, raro, quest, level up)."
  - "Restituisci notes/tags strutturati con motivazioni e tag CTA/MDA coerenti."
  - "Memoria aggiornata: sigilli_tokens/index/level/last_rare/last_quest."
  - "Link portale aggiornato + CTA opzionali."
