name: PR checklist guardrail

on:
  pull_request:
    types: [opened, edited, synchronize]

jobs:
  validate-pr-template:
    needs: qa-autofill
    runs-on: ubuntu-latest
    permissions:
      pull-requests: read
    steps:
      - name: Verifica checklist ed evidenze obbligatorie
        uses: actions/github-script@v6
        with:
          script: |
            const prNumber = context.payload.pull_request?.number;
            const prBody = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
            }).then((res) => res.data.body || '').catch(() => context.payload.pull_request?.body || '') || '';

            const body = prBody.trim();
            const hasAutoQaSection = body.includes('<!-- AUTO-QA-START -->') && body.includes('<!-- AUTO-QA-END -->');
            if (!hasAutoQaSection) {
              core.notice('Sezione AUTO-QA non presente: la validazione della checklist verrà eseguita dopo l\'autofill.');
              return;
            }

            const inProgressTable = /\|\s*In esecuzione\.\.\.\s*\|/i.test(body);
            if (!body || inProgressTable) {
              core.notice('Checklist o tabella QA non ancora compilate: attendere il completamento dell\'autofill.');
              return;
            }

            const requiredChecks = [
              'Test con dump disabilitato (marker/header)',
              'Naming export corretto',
              'CTA QA presenti',
              '401/403 per endpoint protetti',
            ];

            const escape = (value) => value.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');

            const missingChecks = requiredChecks.filter((label) => {
              const rowPattern = new RegExp(`-\\s*\\[\\s*x\\s*\\]\\s*${escape(label)}`, 'i');
              return !rowPattern.test(body);
            });
            if (missingChecks.length) {
              core.setFailed(`Segna come completati tutti i controlli obbligatori: manca ${missingChecks.join(', ')}.`);
            }

            const placeholderPattern = /<[^>]+>/;
            if (placeholderPattern.test(body)) {
              core.setFailed('Sostituisci tutti i placeholder (<...>) con informazioni reali nelle evidenze di test.');
            }

            const missingEvidence = requiredChecks.filter((label) => {
              const rowPattern = new RegExp(`\\|\\s*${escape(label)}\\s*\\|(?:[^|<>]*\\|){2,}`, 'i');
              return !rowPattern.test(body);
            });

            if (missingEvidence.length) {
              core.setFailed(`Aggiungi una riga di evidenza per ogni controllo: manca ${missingEvidence.join(', ')}.`);
            }

  qa-autofill:
    runs-on: ubuntu-latest
    if: ${{ github.event.pull_request.number }}
    permissions:
      pull-requests: write
      contents: read
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      - name: Run static analysis helper
        id: static_check
        run: |
          chmod +x tools/run_static_analysis.sh
          ./tools/run_static_analysis.sh
        continue-on-error: true

      - name: Run API regression tests (dump e 401/403)
        id: app_tests
        run: pytest tests/test_app.py -q
        continue-on-error: true

      - name: Run catalog reference tests
        id: reference_tests
        run: pytest tests/test_generate_build_db.py -k reference
        continue-on-error: true

      - name: Aggiorna corpo PR con esiti QA
        if: ${{ github.event.pull_request.number }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          APP_TEST_CONCLUSION: ${{ steps.app_tests.conclusion }}
          STATIC_CONCLUSION: ${{ steps.static_check.conclusion }}
          REFERENCE_CONCLUSION: ${{ steps.reference_tests.conclusion }}
        run: |
          python - <<'PY'
          import json
          import os
          import re
          import subprocess

          repo = os.environ["GITHUB_REPOSITORY"]
          pr_number = os.environ["PR_NUMBER"]
          run_url = os.environ["RUN_URL"]

          def gh_api(path: str) -> str:
            return subprocess.check_output([
              "gh",
              "api",
              f"repos/{repo}/{path}",
              "--jq",
              ".body",
            ], text=True)

          body = gh_api(f"pulls/{pr_number}") or ""

          results = [
            {
              "label": "Test con dump disabilitato (marker/header)",
              "conclusion": os.environ.get("APP_TEST_CONCLUSION", ""),
              "type": "integration",
            },
            {
              "label": "401/403 per endpoint protetti",
              "conclusion": os.environ.get("APP_TEST_CONCLUSION", ""),
              "type": "integration",
            },
            {
              "label": "Naming export corretto",
              "conclusion": os.environ.get("STATIC_CONCLUSION", ""),
              "type": "static",
            },
            {
              "label": "CTA QA presenti",
              "conclusion": os.environ.get("REFERENCE_CONCLUSION", ""),
              "type": "integration",
            },
          ]

          def status_text(conclusion: str) -> str:
            if not conclusion or conclusion in {"cancelled", "skipped"}:
              return "non eseguito"
            return "pass" if conclusion == "success" else "fail"

          def escape(value: str) -> str:
            return re.escape(value)

          def update_checkbox(text: str, label: str, checked: bool) -> str:
            pattern = re.compile(rf"- \[( |x)\] {escape(label)}")
            replacement = f"- [{'x' if checked else ' '}] {label}"
            if pattern.search(text):
              return pattern.sub(replacement, text)
            return f"{text}\n{replacement}" if text else replacement

          for result in results:
            body = update_checkbox(body, result["label"], result["conclusion"] == "success")

          start_marker = "<!-- AUTO-QA-START -->"
          end_marker = "<!-- AUTO-QA-END -->"
          header = "| Controllo | Storia collegata | Tipo di test (unit/integration/manuale) | Evidenza (link/log, includere header/marker rilevante) |"
          separator = "| --- | --- | --- | --- |"
          rows = [
            f"| {res['label']} | AUTO-QA | {res['type']} | [Log esecuzione]({run_url}) — esito: {status_text(res['conclusion'])} |"
            for res in results
          ]
          auto_table = "\n".join([start_marker, header, separator, *rows, end_marker])

          block_regex = re.compile(rf"{re.escape(start_marker)}[\s\S]*?{re.escape(end_marker)}", re.MULTILINE)
          if block_regex.search(body):
            body = block_regex.sub(auto_table, body)
          else:
            if body and not body.endswith("\n"):
              body += "\n"
            body = f"{body}\n{auto_table}" if body else auto_table

          payload = json.dumps({"body": body})

          subprocess.run([
            "gh",
            "api",
            f"repos/{repo}/pulls/{pr_number}",
            "--method",
            "PATCH",
            "--input",
            "-",
          ], input=payload.encode(), check=True)
          PY

      - name: Verifica marker e esiti QA
        if: always()
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          STATIC_CONCLUSION: ${{ steps.static_check.conclusion }}
          APP_TEST_CONCLUSION: ${{ steps.app_tests.conclusion }}
          REFERENCE_CONCLUSION: ${{ steps.reference_tests.conclusion }}
        run: |
          failures=()

          check_outcome() {
            local label="$1"
            local conclusion="$2"
            if [ -z "$conclusion" ] || [ "$conclusion" = "skipped" ]; then
              failures+=("${label}: job non eseguito o skippato")
            elif [ "$conclusion" != "success" ]; then
              failures+=("${label}: esito ${conclusion}")
            fi
          }

          check_outcome "Naming export corretto" "$STATIC_CONCLUSION"
          check_outcome "Test con dump disabilitato (marker/header)" "$APP_TEST_CONCLUSION"
          check_outcome "CTA QA presenti" "$REFERENCE_CONCLUSION"
          check_outcome "401/403 per endpoint protetti" "$APP_TEST_CONCLUSION"

          body=$(gh api "repos/${GITHUB_REPOSITORY}/pulls/${PR_NUMBER}" --jq .body)
          if [[ "$body" != *"<!-- AUTO-QA-START -->"* || "$body" != *"<!-- AUTO-QA-END -->"* ]]; then
            failures+=("Sezione AUTO-QA mancante nel corpo della PR")
          fi

          if [ ${#failures[@]} -gt 0 ]; then
            printf 'Verifiche QA non superate:\n'
            printf ' - %s\n' "${failures[@]}"
            exit 1
          fi

          echo "Tutte le verifiche QA sono state completate con successo."
